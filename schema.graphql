enum BadgeStatus {
  Absent
  Requested
  Approved
  Challenged
  RequestRemoval
}

enum KlerosRequestType {
  Registration # Identifies a request to register an item to the registry.
  Clearing # Identifies a request to remove an item from the registry.
}

enum Controller {
  kleros
}

## - BADGE TYPE

type BadgeModel @entity {
  id: ID! # BadgeType id
  uri: String!
  controllerType: String!
  validFor: BigInt!
  creatorFee: BigInt!
  paused: Boolean!
  creator: User!
  badgesMintedAmount: BigInt!
  createdAt: BigInt!

  badgeModelKleros: BadgeModelKlerosMetaData @derivedFrom(field: "badgeModelId")
  mintedBadges: [Badge!]! @derivedFrom(field: "badgeModel")
}

type BadgeModelKlerosMetaData @entity {
  id: ID!
  badgeModelId: BadgeModel!
  registrationUri: String!
  removalUri: String!
  tcrList: Bytes!
  submissionBaseDeposit: BigInt!
  challengePeriodDuration: BigInt!
  #TODO: set governor, arbitrator, etc
}

# type KlerosBadgeModelArbitrationParams @entity {
#   id: ID! # badgeModel-index
# }

## - BADGE

type Badge @entity {
  id: ID!
  badgeModel: BadgeModel!
  uri: String!
  account: User! # The receiver of the badge
  status: BadgeStatus!
  validFor: BigInt!
  createdAt: BigInt!
  badgeKlerosMetaData: BadgeKlerosMetaData @derivedFrom(field: "badge")
}

type BadgeKlerosMetaData @entity {
  id: ID! # the same as ID as the BADGE
  badge: Badge!
  itemID: Bytes!
  reviewDueDate: BigInt! # The timestamp when the review period ends. if zero, it does not have review period
  # requests: [KlerosBadgeRequest!]!
  requests: KlerosBadgeRequest @derivedFrom(field: "badgeKlerosMetaData")
}

type KlerosBadgeIdToBadgeId @entity {
  id: ID! # itemID from kleros.
  badgeId: String! # badge id.
}

type KlerosBadgeRequest @entity {
  id: ID!
  type: KlerosRequestType!
  createdAt: BigInt!
  badgeKlerosMetaData: BadgeKlerosMetaData!
  requestIndex: BigInt!
  arbitrationParamsIndex: BigInt!

  #disputeId: BigInt!
  requester: Bytes!
  #challenger: Bytes

  # TODO: Replace with evidences()
  requestBadgeEvidenceUri: String
  removeOrChallengeEvidenceUri: String
  extraEvidenceUris: [String!]!
}

## - USER

type User @entity {
  id: ID!
  badges: [Badge!] @derivedFrom(field: "account") # TODO: check how to handle different types of badges
  mintedBadgesAmount: BigInt!
  # creator
  isCreator: Boolean!
  isVerified: Boolean!
  createdBadgeModels: [BadgeModel!] @derivedFrom(field: "creator")
  creatorUri: String
  createdBadgesModelAmount: BigInt!
}
