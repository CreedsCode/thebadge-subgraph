enum BadgeStatus {
  InReview
  Approved
  Rejected
  Revoked
}

enum KlerosRequestType {
  Registration # Identifies a request to register an item to the registry.
  Clearing # Identifies a request to remove an item from the registry.
}

enum Controller {
  kleros
}

enum KlerosStatus {
  Absent # The item is not in the registry.
  Registered # The item is in the registry.
  RegistrationRequested # The item has a request to be added to the registry.
  ClearingRequested # The item has a request to be removed from the registry.
}

## - BADGE TYPE

type BadgeType @entity {
  id: ID! # BadgeType id
  metadataURL: String!
  controllerName: String!
  mintCost: BigInt!
  validFor: BigInt!
  paused: Boolean!
  creator: User!

  klerosBadge: KlerosBadgeType @derivedFrom(field: "badgeTypeId")

  mintedBadges: [Badge!]! @derivedFrom(field: "badgeType")
  badgesMintedAmount: BigInt!
}

type KlerosBadgeType @entity {
  id: ID! # BadgeType.id
  badgeTypeId: BadgeType!
  metadataURL: String! # TODO: handle all the possible files that can be updated.
  #TODO: set governor and other values
  tcrList: Bytes!
  submissionBaseDeposit: BigInt!
  challengePeriodDuration: BigInt!
  #TODO: set arbitrator
  #TODO: set arbitrator params
  #TODO: set arbitratorParamsIndex
}

# type KlerosBadgeTypeArbitrationParams @entity {
#   id: ID! # badgeType-index
# }

## - BADGE

type Badge @entity {
  id: ID!
  badgeType: BadgeType!
  receiver: User! # The receiver of the badge
  requestedBy: Bytes! # The address who initiated the request.
  validFor: BigInt!
}

type KlerosBadge @entity {
  id: ID! # the same as ID as the BADGE
  badge: Badge!
  status: KlerosStatus!
  itemID: Bytes!
  reviewDueDate: BigInt! # The timestamp when the review period ends. if zero, it does not have review period
  isChallenged: Boolean! # marked to true when is challenged and to false when was ruled.
  requests: [KlerosBadgeRequest!]!
}

type KlerosBadgeRequest @entity {
  id: ID! # TODO: for now, it will be badgeType-address-requestIndex, will be migrated later to badgeID.
  type: KlerosRequestType!
  submissionTime: BigInt!
  arbitrationParamsIndex: BigInt!
  requester: Bytes!
}

## - USER

type User @entity {
  id: ID!
  badges: [Badge!] @derivedFrom(field: "receiver") # TODO: check how to handle different types of badges
  mintedBadgesAmount: BigInt!
  # creator
  isCreator: Boolean!
  isVerified: Boolean!
  createdBadgeTypes: [BadgeType!] @derivedFrom(field: "creator")
  creatorMetadata: String
  createdBadgesTypesAmount: BigInt!
}
